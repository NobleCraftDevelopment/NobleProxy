package ir.xenoncommunity.modules.impl;

import io.netty.buffer.ByteBuf;
import io.netty.channel.ChannelHandlerContext;
import io.netty.handler.codec.MessageToMessageDecoder;
import ir.xenoncommunity.XenonCore;
import ir.xenoncommunity.annotations.ModuleListener;
import ir.xenoncommunity.commands.XenonCord;
import net.md_5.bungee.api.event.PacketReceiveEvent;
import net.md_5.bungee.api.event.PreLoginEvent;
import net.md_5.bungee.api.plugin.Listener;
import net.md_5.bungee.event.EventHandler;
import net.md_5.bungee.protocol.packet.Handshake;

import java.util.List;

@SuppressWarnings("unused")
@ModuleListener(isExtended = false, isImplemented = true)
public class ExploitPatcher extends MessageToMessageDecoder<ByteBuf> implements Listener {
    private static final int MAX_PACKET_SIZE = 4096;
    private static final int MAX_HANDSHAKE_LENGTH = 255;

    @EventHandler
    public void onPreLogin(PreLoginEvent event) {
        try {
            final String host = event.getConnection().getVirtualHost().getHostString();
            if(!(host != null && host.length() <= 255 && host.matches("[a-zA-Z0-9.-]+")))
                event.setCancelled(true);
        } catch (Exception var3) {
            XenonCore.instance.logdebugerror("Error while handling pre-login event");
            event.setCancelled(true);
        }
    }
//    @EventHandler
//    public void onPacketReceive(PacketReceiveEvent e) {
//        final ByteBuf buf = e.getPacket().buf.duplicate();
//        final byte[] packetData = new byte[buf.readableBytes()];
//        buf.getBytes(0, packetData);
//
//        if (packetData.length > MAX_PACKET_SIZE) {
//            e.setCancelled(true);
//            return;
//        }
//    }
    protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) {
        try {
            if (in.readableBytes() > MAX_PACKET_SIZE) {
                ctx.close();
                return;
            }

            in.markReaderIndex();
            if (this.readVarInt(in)== 0) {
                final Handshake handshake = this.readHandshake(in);
                if (handshake != null && handshake.getHost().length() > MAX_HANDSHAKE_LENGTH) {
                    ctx.close();
                    return;
                }
            }

            in.resetReaderIndex();
            out.add(in.retain());
        } catch (Exception e) {
            XenonCore.instance.logdebugerror("Error while handling decode");
            e.printStackTrace();
            ctx.close();
        }
    }


    private int readVarInt(ByteBuf buf) {
        int value = 0;
        int size = 0;

        byte b;
        do {
            b = buf.readByte();
            value |= (b & 127) << size++ * 7;
            if (size > 5) {
                XenonCore.instance.logdebugerror("Error while handling readvarint");
                throw new RuntimeException("VarInt too large");
            }
        } while((b & 128) == 128);

        return value;
    }

    private Handshake readHandshake(ByteBuf buf) {
        try {
            final int protocolVersion = this.readVarInt(buf);
            final String host = this.readString(buf);
            final int port = buf.readUnsignedShort();
            final int nextState = this.readVarInt(buf);
            return new Handshake(protocolVersion, host, port, nextState);
        } catch (Exception e) {
            XenonCore.instance.logdebugerror("Error while handling readhandshake");
            e.printStackTrace();
            return null;
        }
    }

    private String readString(ByteBuf buf) {
        final int length = this.readVarInt(buf);
        if (length <= 255 && length >= 0) {
            final byte[] bytes = new byte[length];
            buf.readBytes(bytes);
            return new String(bytes);
        } else {
            XenonCore.instance.logdebugerror("Error while handling readstring");
            throw new IllegalArgumentException("String length exceeds limit");
        }
    }
}
